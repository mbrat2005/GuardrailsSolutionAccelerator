# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

pr:
  branches:
    include: 
      - main

pool:
  vmImage: windows-latest

variables: 
  - group: 'GuardrailsTestDeployments'

steps:

- task: EsrpCodeSigning@1
  inputs:
    ConnectedServiceName: 'ESRP Guardrails Accelerator Signing'
    FolderPath: './'
    Pattern: '*ps*'
    signConfigType: 'inlineSignParams'
    inlineOperation: |
        [{
            "KeyCode" : "CP-230012",
            "OperationCode" : "SigntoolSign",
            "Parameters" : {
                "OpusName" : "Microsoft",
                "OpusInfo" : "http://www.microsoft.com",
                "FileDigest" : "/fd \"SHA256\"",
                "PageHash" : "/NPH",
                "TimeStamp" : "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
            },
            "ToolName" : "sign",
            "ToolVersion" : "1.0"
        },
        {
            "KeyCode" : "CP-230012",
            "OperationCode" : "SigntoolVerify",
            "Parameters" : {},
            "ToolName" : "sign",
            "ToolVersion" : "1.0"
        }]
    SessionTimeout: '60'
    MaxConcurrency: '50'
    MaxRetryAttempts: '5'
  enabled: true

#look for hash mismatch
- powershell: |
    $signatureStatuses = Get-ChildItem -r -i *.ps* | Get-AuthenticodeSignature

    Foreach ($signatureStatus in $signatureStatuses) {
      If ($signatureStatus.Status -eq 'HashMismatch') {
        throw "File '$($signatureStatus.Path)' has a hash status of '$($signatureStatus.status)'"
      }
      ElseIf ($signatureStatus.Status -eq 'NotSigned') {
        Write-Warning "File '$($signatureStatus.Path)' has a hash status of '$($signatureStatus.status)'"
      }
      ElseIf ($signatureStatus.Status -eq 'Valid') {
        Write-Host "File '$($signatureStatus.Path)' has a hash status of '$($signatureStatus.status)'"
      }
      Else {
        throw "File '$($signatureStatus.Path)' has an unhandled hash status of '$($signatureStatus.status)'"
      }
    }
  name: CheckForSignFailures

#test module imports
- powershell: |
    $ErrorActionPreference = 'Stop'

    $moduleFiles = Get-ChildItem -path ./* -recurse -include *.psm1
    Write-Host "Count of module files: $($moduleFiles.count)"
    
    try {
      ForEach ($moduleFile in $moduleFiles) {
        Import-Module $moduleFile.Fullname -ErrorAction Stop
      }
    }
    catch {
      throw "Failed test import module '$moduleFile' with error: $_"
    }

    $importedModules = Get-Module
    Write-Host "Imported modules: `n $($importedModules.Path | Out-String)"

    $missingModules = $moduleFiles | Where-object {$_ -inotin ($importedModules).Path} 
    If ($missingModules) {
      throw "The following modules failed import test: $missingModules"
    }
  name: TestModuleImports

- powershell: |
    Write-Host "Executing powershell script in '$pwd'"
    gci env: | FT -AutoSize
    #gci $env:BUILD_REPOSITORY_LOCALPATH`/src | FT -AutoSize
    
    $files = $env:GETFILESCHANGEDINPR_FILESCHANGEDINLASTPR.split(';')
    Write-Host "Total '$($files.count)' files changed in last commit. Files: `n $files"

    $moduleManifestFiles = $files | Where-Object {$_ -like '*.psm1'}
    Write-Host "'$($moduleManifestFiles.count)' module manifest files changed in last commit"

    try {
      $moduleManifestFilesObjs = @()

      ForEach ($file in $moduleManifestFiles) {
        $moduleManifestFilesObjs += Get-Item -Path $file -ErrorAction Stop
      }
    }
    catch {
      Write-Error "Failed to find file path '$file' with Get-Item -Path '$file'; Error: $_"
    }

    $zipsChanged = $false
    ForEach ($moduleManifest in $moduleManifestFilesObjs) {
        $moduleCodeFile = Get-Item -Path $moduleManifest.FullName.replace('psd1','psm1')
        
        If ($moduleManifestFilesObjs.FullName -icontains $moduleManifest.FullName -or $moduleManifestFilesObjs.FullName -icontains $moduleCodeFile.FullName) {
          Write-Host "Module '$($moduleManifest.BaseName)' was changed, zipping module files..."

          $destPath = "./psmodules/$($moduleManifest.BaseName).zip"
          Compress-Archive -Path "$($moduleManifest.Directory)/*" -DestinationPath $destPath -Update

          $zipsChanged = $true
        }
        Else {
            Write-Host "Neither the manifest '$($moduleManifest.FullName.toLower())' or script file '$($moduleCodeFile.FullName.ToLower())' for module '$($moduleManifest.BaseName)' was changed, skipping zipping..."
        }
    }

    # output whether modules were changed
    Write-Output ("##vso[task.setvariable variable=filesZipped;isOutput=true]$($moduleManifestFilesObjs.count -gt 0)")
  displayName: 'Zip signed modules'
  name: 'ZipFiles'
  enabled: false

- powershell: |
    Write-Host "Executing powershell script in '$pwd'"
    gci env: | FT -AutoSize
    #gci $env:BUILD_REPOSITORY_LOCALPATH`/src | FT -AutoSize
    

    $moduleManifestFilesObjs = Get-ChildItem -Path .\src -Recurse -Include *.psm1
    Write-Host "'$($moduleManifestFiles.count)' module manifest files "

    ForEach ($moduleManifest in $moduleManifestFilesObjs) {
        $moduleCodeFile = Get-Item -Path $moduleManifest.FullName.replace('psd1','psm1')
        
        If ($moduleManifestFilesObjs.FullName -icontains $moduleManifest.FullName -or $moduleManifestFilesObjs.FullName -icontains $moduleCodeFile.FullName) {
          Write-Host "Module '$($moduleManifest.BaseName)' found, zipping module files..."

          $destPath = "./psmodules/$($moduleManifest.BaseName).zip"
          Compress-Archive -Path "$($moduleManifest.Directory)/*" -DestinationPath $destPath -Force

        }
        Else {
            Write-Host "Neither the manifest '$($moduleManifest.FullName.toLower())' or script file '$($moduleCodeFile.FullName.ToLower())' for module '$($moduleManifest.BaseName)' was changed, skipping zipping..."
        }
    }

    # output whether modules were changed
    Write-Output ("##vso[task.setvariable variable=filesZipped;isOutput=true]$($true)")
  displayName: 'Zip signed modules'
  name: 'ZipAllFiles'
  enabled: true

- task: AzurePowerShell@5
  inputs:
    azureSubscription: 'Matthew Visual Studio (mb_co)'
    ScriptType: 'InlineScript'
    FailOnStandardError: true
    azurePowerShellVersion: 'LatestVersion'
    pwsh: true
    Inline: |
      $configFilePath = Join-Path -Path $env:AGENT_TEMPDIRECTORY -ChildPath 'config.json'

      $configContent = @'
      {
          "keyVaultName": "guardrails",
          "resourcegroup": "Guardrails",
          "region": "CanadaCentral",
          "storageaccountName": "guardrail",
          "logAnalyticsworkspaceName": "guardrails",
          "autoMationAccountName": "guardrails",
          "FirstBreakGlassAccountUPN": "breakglass1@$(testTenantDomain)",
          "SecondBreakGlassAccountUPN": "breakglass2@$(testTenantDomain)",
          "PBMMPolicyID": "4c4a5f27-de81-430b-b4e5-9cbd50595a87",
          "AllowedLocationPolicyId": "e56962a6-4747-49cd-b67b-bf8b01975c4c",
          "DepartmentNumber": "",
          "CBSSubscriptionName": "$(CBSSubscriptionName)",
          "SecurityLAWResourceId": "/subscriptions/$(testSubscriptionId)/resourceGroups/rg-core/providers/Microsoft.OperationalInsights/workspaces/mtb-law01",
          "HealthLAWResourceId": "/subscriptions/$(testSubscriptionId)/resourceGroups/rg-core/providers/Microsoft.OperationalInsights/workspaces/mtb-law01",
          "Locale": "en-CA",
          "lighthouseServiceProviderTenantID": "$(lighthouseProviderTenantId)",
          "lighthousePrincipalDisplayName": "SSC CSPM TEAM",
          "lighthousePrincipalId": "$(lighthousePrincipalId)",
          "lighthouseTargetManagementGroupID": "mb_co"
        }
      '@
      Set-Content -Path $configFilePath -Value $configContent

      $userId = '$(testUserId)@$(testTenantDomain)'
      $alternatePSModulesURL = "{0}/raw/{1}/psmodules" -f $env:BUILD_REPOSITORY_URI,$env:BUILD_SOURCEBRANCHNAME
      Write-Output "alternatePSModulesURL is '$alternatePSModulesURL'"

      Push-Location -Path setup

      try {
          $ErrorActionPreference = 'Stop'
          ./setup.ps1 -configFilePath $configFilePath -configureLighthouseAccessDelegation -alternatePSModulesURL $alternatePSModulesURL -Yes -Verbose
      }
      catch {
          throw "Failed test deploy of solution with error: $_"
      }
      finally {
        If (!$?) {throw "Failed test deploy of solution with error: $($error[0]) $_"}
        Pop-Location
      }
  name: 'TestSolutionDeploy'

- task: AzurePowerShell@5
  name: 'CheckForJobErrors'
  displayName: 'Check for AA Job Errors'
  inputs:
    azureSubscription: 'Matthew Visual Studio (mb_co)'
    ScriptType: 'InlineScript'
    FailOnStandardError: true
    azurePowerShellVersion: 'LatestVersion'
    pwsh: true
    Inline: |
      ipmo ./src/GuardrailsSolutionAcceleratorSetup

      $c = Get-GSAExportedConfig -KeyVaultName guardrails-5c060f8e -y
      $config = $c.configString | ConvertFrom-Json
      
      $timeout = New-TimeSpan -Minutes 5
      $timer = [System.Diagnostics.Stopwatch]::StartNew()
      do {
        $job = Get-AzAutomationJob -RunbookName 'main' -ResourceGroupName $config.runtime.resourceGroup -AutomationAccountName $config.runtime.automationAccountName | 
          Sort-Object StartTIme -Descending |
          Select-Object -First 1
      }
      until (($job.Status -in 'Completed','Failed') -or ($timer.Elapsed -ge $timeout))

      If ($job.Status -eq 'Failed') {
        throw "main runbook failed to execute"
      }

      $jobOutput = Get-AzAutomationJobOutput -Id $job.JobId -ResourceGroupName $config.runtime.resourceGroup -AutomationAccountName $config.runtime.automationAccountName

      ForEach ($outputRecord in $jobOutput) {
        If ($outputRecord.Summary -like 'Failed invoke the module execution script for module*') {
          Write-Output ("##vso[task.setvariable variable=skipCleanup;isOutput=true]$($true)")
          throw "Module execution error found in deployment"
        }
      }

- task: AzurePowerShell@5
  condition: always()
  inputs:
    azureSubscription: 'Matthew Visual Studio (mb_co)'
    ScriptType: 'InlineScript'
    FailOnStandardError: true
    azurePowerShellVersion: 'LatestVersion'
    pwsh: true
    Inline: |
      If (-NOT($env:SKIPCLEANUP)) {
        ipmo ./src/GuardrailsSolutionAcceleratorSetup

        $c = Get-GSAExportedConfig -KeyVaultName guardrails-5c060f8e -y
        $config = $c.configString | ConvertFrom-Json

        $c | remove-gsacentralizedReportingCustomerComponents -Force
        $c | Remove-GSACentralizedDefenderCustomerComponents -Force
        $c | Remove-GSACoreResources -Force -Wait
      }
      Else {
        Write-Host "Skipping cleanup because `$env:skipCleanup is true"
      }
  name: 'CleanUpTest'


- powershell: |
    $dest = "{0}/{1}.zip" -f $ENV:BUILD_ARTIFACTSTAGINGDIRECTORY,(get-date -f 'yyyy-MM-dd-HH-mm-ss')
    Compress-Archive -Path ./* -DestinationPath $ENV:BUILD_ARTIFACTSTAGINGDIRECTORY/$(get-date -f 'yyyy-MM-dd-HH-mm-ss').zip
  name: 'zipartifact'

- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'drop'
    publishLocation: 'Container'
